// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __client_hh__
#define __client_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_client
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_client
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_client
#endif



#ifndef __orbTypes_hh_EXTERNAL_GUARD__
#define __orbTypes_hh_EXTERNAL_GUARD__
#include <orbTypes.h>
#endif
#ifndef __pusher_hh_EXTERNAL_GUARD__
#define __pusher_hh_EXTERNAL_GUARD__
#include <pusher.h>
#endif



#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE STI

_CORBA_MODULE_BEG

  _CORBA_MODULE Client_Server

  _CORBA_MODULE_BEG

#ifndef __STI_mClient__Server_mModeHandler__
#define __STI_mClient__Server_mModeHandler__

    class ModeHandler;
    class _objref_ModeHandler;
    class _impl_ModeHandler;
    
    typedef _objref_ModeHandler* ModeHandler_ptr;
    typedef ModeHandler_ptr ModeHandlerRef;

    class ModeHandler_Helper {
    public:
      typedef ModeHandler_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ModeHandler, ModeHandler_Helper> ModeHandler_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ModeHandler,ModeHandler_Helper > ModeHandler_out;

#endif

#ifndef __STI_mClient__Server_mParser__
#define __STI_mClient__Server_mParser__

    class Parser;
    class _objref_Parser;
    class _impl_Parser;
    
    typedef _objref_Parser* Parser_ptr;
    typedef Parser_ptr ParserRef;

    class Parser_Helper {
    public:
      typedef Parser_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_Parser, Parser_Helper> Parser_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_Parser,Parser_Helper > Parser_out;

#endif

#ifndef __STI_mClient__Server_mExpSequence__
#define __STI_mClient__Server_mExpSequence__

    class ExpSequence;
    class _objref_ExpSequence;
    class _impl_ExpSequence;
    
    typedef _objref_ExpSequence* ExpSequence_ptr;
    typedef ExpSequence_ptr ExpSequenceRef;

    class ExpSequence_Helper {
    public:
      typedef ExpSequence_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ExpSequence, ExpSequence_Helper> ExpSequence_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ExpSequence,ExpSequence_Helper > ExpSequence_out;

#endif

#ifndef __STI_mClient__Server_mServerTimingSeqControl__
#define __STI_mClient__Server_mServerTimingSeqControl__

    class ServerTimingSeqControl;
    class _objref_ServerTimingSeqControl;
    class _impl_ServerTimingSeqControl;
    
    typedef _objref_ServerTimingSeqControl* ServerTimingSeqControl_ptr;
    typedef ServerTimingSeqControl_ptr ServerTimingSeqControlRef;

    class ServerTimingSeqControl_Helper {
    public:
      typedef ServerTimingSeqControl_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ServerTimingSeqControl, ServerTimingSeqControl_Helper> ServerTimingSeqControl_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ServerTimingSeqControl,ServerTimingSeqControl_Helper > ServerTimingSeqControl_out;

#endif

#ifndef __STI_mClient__Server_mRegisteredDevices__
#define __STI_mClient__Server_mRegisteredDevices__

    class RegisteredDevices;
    class _objref_RegisteredDevices;
    class _impl_RegisteredDevices;
    
    typedef _objref_RegisteredDevices* RegisteredDevices_ptr;
    typedef RegisteredDevices_ptr RegisteredDevicesRef;

    class RegisteredDevices_Helper {
    public:
      typedef RegisteredDevices_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_RegisteredDevices, RegisteredDevices_Helper> RegisteredDevices_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_RegisteredDevices,RegisteredDevices_Helper > RegisteredDevices_out;

#endif

#ifndef __STI_mClient__Server_mServerCommandLine__
#define __STI_mClient__Server_mServerCommandLine__

    class ServerCommandLine;
    class _objref_ServerCommandLine;
    class _impl_ServerCommandLine;
    
    typedef _objref_ServerCommandLine* ServerCommandLine_ptr;
    typedef ServerCommandLine_ptr ServerCommandLineRef;

    class ServerCommandLine_Helper {
    public:
      typedef ServerCommandLine_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ServerCommandLine, ServerCommandLine_Helper> ServerCommandLine_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ServerCommandLine,ServerCommandLine_Helper > ServerCommandLine_out;

#endif

#ifndef __STI_mClient__Server_mClientBootstrap__
#define __STI_mClient__Server_mClientBootstrap__

    class ClientBootstrap;
    class _objref_ClientBootstrap;
    class _impl_ClientBootstrap;
    
    typedef _objref_ClientBootstrap* ClientBootstrap_ptr;
    typedef ClientBootstrap_ptr ClientBootstrapRef;

    class ClientBootstrap_Helper {
    public:
      typedef ClientBootstrap_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ClientBootstrap, ClientBootstrap_Helper> ClientBootstrap_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ClientBootstrap,ClientBootstrap_Helper > ClientBootstrap_out;

#endif

    // interface ClientBootstrap
    class ClientBootstrap {
    public:
      // Declarations for this interface type.
      typedef ClientBootstrap_ptr _ptr_type;
      typedef ClientBootstrap_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_ClientBootstrap :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      ::CORBA::Boolean connect(Pusher::ServerEventHandler_ptr eventHandler);
      ModeHandler_ptr getModeHandler();
      Parser_ptr getParser();
      ExpSequence_ptr getExpSequence();
      ServerTimingSeqControl_ptr getServerTimingSeqControl();
      RegisteredDevices_ptr getRegisteredDevices();
      ServerCommandLine_ptr getServerCommandLine();

      inline _objref_ClientBootstrap()  { _PR_setobj(0); }  // nil
      _objref_ClientBootstrap(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_ClientBootstrap();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_ClientBootstrap(const _objref_ClientBootstrap&);
      _objref_ClientBootstrap& operator = (const _objref_ClientBootstrap&);
      // not implemented

      friend class ClientBootstrap;
    };

    class _pof_ClientBootstrap : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_ClientBootstrap() : _OMNI_NS(proxyObjectFactory)(ClientBootstrap::_PD_repoId) {}
      virtual ~_pof_ClientBootstrap();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_ClientBootstrap :
      public virtual omniServant
    {
    public:
      virtual ~_impl_ClientBootstrap();

      virtual ::CORBA::Boolean connect(Pusher::ServerEventHandler_ptr eventHandler) = 0;
      virtual ModeHandler_ptr getModeHandler() = 0;
      virtual Parser_ptr getParser() = 0;
      virtual ExpSequence_ptr getExpSequence() = 0;
      virtual ServerTimingSeqControl_ptr getServerTimingSeqControl() = 0;
      virtual RegisteredDevices_ptr getRegisteredDevices() = 0;
      virtual ServerCommandLine_ptr getServerCommandLine() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mModeInterrupt__
#define __STI_mClient__Server_mModeInterrupt__

    class ModeInterrupt;
    class _objref_ModeInterrupt;
    class _impl_ModeInterrupt;
    
    typedef _objref_ModeInterrupt* ModeInterrupt_ptr;
    typedef ModeInterrupt_ptr ModeInterruptRef;

    class ModeInterrupt_Helper {
    public:
      typedef ModeInterrupt_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ModeInterrupt, ModeInterrupt_Helper> ModeInterrupt_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ModeInterrupt,ModeInterrupt_Helper > ModeInterrupt_out;

#endif

    // interface ModeInterrupt
    class ModeInterrupt {
    public:
      // Declarations for this interface type.
      typedef ModeInterrupt_ptr _ptr_type;
      typedef ModeInterrupt_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_ModeInterrupt :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      void requestControl(const char* myName, const char* ipAddress);
      void controlTakenBy(const char* myName, const char* ipAddress);

      inline _objref_ModeInterrupt()  { _PR_setobj(0); }  // nil
      _objref_ModeInterrupt(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_ModeInterrupt();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_ModeInterrupt(const _objref_ModeInterrupt&);
      _objref_ModeInterrupt& operator = (const _objref_ModeInterrupt&);
      // not implemented

      friend class ModeInterrupt;
    };

    class _pof_ModeInterrupt : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_ModeInterrupt() : _OMNI_NS(proxyObjectFactory)(ModeInterrupt::_PD_repoId) {}
      virtual ~_pof_ModeInterrupt();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_ModeInterrupt :
      public virtual omniServant
    {
    public:
      virtual ~_impl_ModeInterrupt();

      virtual void requestControl(const char* myName, const char* ipAddress) = 0;
      virtual void controlTakenBy(const char* myName, const char* ipAddress) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mModeHandler__
#define __STI_mClient__Server_mModeHandler__

    class ModeHandler;
    class _objref_ModeHandler;
    class _impl_ModeHandler;
    
    typedef _objref_ModeHandler* ModeHandler_ptr;
    typedef ModeHandler_ptr ModeHandlerRef;

    class ModeHandler_Helper {
    public:
      typedef ModeHandler_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ModeHandler, ModeHandler_Helper> ModeHandler_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ModeHandler,ModeHandler_Helper > ModeHandler_out;

#endif

    // interface ModeHandler
    class ModeHandler {
    public:
      // Declarations for this interface type.
      typedef ModeHandler_ptr _ptr_type;
      typedef ModeHandler_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_ModeHandler :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      ::CORBA::Boolean requestControl(const char* myName, const char* ipAddress, ModeInterrupt_ptr interrupt);
      ::CORBA::Boolean takeControl(const char* myName, const char* ipAddress, ModeInterrupt_ptr interrupt);
      void cancelRequest();
      void answerRequest(::CORBA::Boolean yield);
      char* controllerName();
      char* controllerIP();

      inline _objref_ModeHandler()  { _PR_setobj(0); }  // nil
      _objref_ModeHandler(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_ModeHandler();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_ModeHandler(const _objref_ModeHandler&);
      _objref_ModeHandler& operator = (const _objref_ModeHandler&);
      // not implemented

      friend class ModeHandler;
    };

    class _pof_ModeHandler : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_ModeHandler() : _OMNI_NS(proxyObjectFactory)(ModeHandler::_PD_repoId) {}
      virtual ~_pof_ModeHandler();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_ModeHandler :
      public virtual omniServant
    {
    public:
      virtual ~_impl_ModeHandler();

      virtual ::CORBA::Boolean requestControl(const char* myName, const char* ipAddress, ModeInterrupt_ptr interrupt) = 0;
      virtual ::CORBA::Boolean takeControl(const char* myName, const char* ipAddress, ModeInterrupt_ptr interrupt) = 0;
      virtual void cancelRequest() = 0;
      virtual void answerRequest(::CORBA::Boolean yield) = 0;
      virtual char* controllerName() = 0;
      virtual char* controllerIP() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mParser__
#define __STI_mClient__Server_mParser__

    class Parser;
    class _objref_Parser;
    class _impl_Parser;
    
    typedef _objref_Parser* Parser_ptr;
    typedef Parser_ptr ParserRef;

    class Parser_Helper {
    public:
      typedef Parser_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_Parser, Parser_Helper> Parser_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_Parser,Parser_Helper > Parser_out;

#endif

    // interface Parser
    class Parser {
    public:
      // Declarations for this interface type.
      typedef Parser_ptr _ptr_type;
      typedef Parser_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_Parser :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      ::CORBA::Boolean parseFile(const char* filename);
      ::CORBA::Boolean parseString(const char* code);
      ::CORBA::Boolean parseLoopScript(const char* script);
      ::CORBA::Boolean stringToMixedValue(const char* code, Types::TValMixed_out value);
      Types::TOverwrittenSeq* overwritten();
      void overwritten(const Types::TOverwrittenSeq& _v);
      ::CORBA::Boolean lockOnParse();
      void lockOnParse(::CORBA::Boolean _v);
      char* outMsg();
      char* errMsg();
      char* mainFile();
      Types::TChannelSeq* channels();
      Types::TStringSeq* files();
      Types::TVariableSeq* variables();
      Types::TEventSeq* events();

      inline _objref_Parser()  { _PR_setobj(0); }  // nil
      _objref_Parser(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_Parser();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_Parser(const _objref_Parser&);
      _objref_Parser& operator = (const _objref_Parser&);
      // not implemented

      friend class Parser;
    };

    class _pof_Parser : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_Parser() : _OMNI_NS(proxyObjectFactory)(Parser::_PD_repoId) {}
      virtual ~_pof_Parser();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_Parser :
      public virtual omniServant
    {
    public:
      virtual ~_impl_Parser();

      virtual ::CORBA::Boolean parseFile(const char* filename) = 0;
      virtual ::CORBA::Boolean parseString(const char* code) = 0;
      virtual ::CORBA::Boolean parseLoopScript(const char* script) = 0;
      virtual ::CORBA::Boolean stringToMixedValue(const char* code, Types::TValMixed_out value) = 0;
      virtual Types::TOverwrittenSeq* overwritten() = 0;
      virtual void overwritten(const Types::TOverwrittenSeq& _v) = 0;
      virtual ::CORBA::Boolean lockOnParse() = 0;
      virtual void lockOnParse(::CORBA::Boolean _v) = 0;
      virtual char* outMsg() = 0;
      virtual char* errMsg() = 0;
      virtual char* mainFile() = 0;
      virtual Types::TChannelSeq* channels() = 0;
      virtual Types::TStringSeq* files() = 0;
      virtual Types::TVariableSeq* variables() = 0;
      virtual Types::TEventSeq* events() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mExpSequence__
#define __STI_mClient__Server_mExpSequence__

    class ExpSequence;
    class _objref_ExpSequence;
    class _impl_ExpSequence;
    
    typedef _objref_ExpSequence* ExpSequence_ptr;
    typedef ExpSequence_ptr ExpSequenceRef;

    class ExpSequence_Helper {
    public:
      typedef ExpSequence_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ExpSequence, ExpSequence_Helper> ExpSequence_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ExpSequence,ExpSequence_Helper > ExpSequence_out;

#endif

    // interface ExpSequence
    class ExpSequence {
    public:
      // Declarations for this interface type.
      typedef ExpSequence_ptr _ptr_type;
      typedef ExpSequence_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_ExpSequence :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      ::CORBA::Boolean setExpSequence(const Types::TStringSeq& Variables, const Types::TRowSeq& Experiments);
      ::CORBA::Boolean appendRow(const Types::TStringSeq& newRow);
      ::CORBA::Boolean moveRow(::CORBA::ULong oldPos, ::CORBA::ULong newPos);
      ::CORBA::Boolean editRow(::CORBA::ULong pos, const Types::TRow& newRow);
      ::CORBA::Boolean deleteRow(::CORBA::ULong pos);
      void clear();
      ::CORBA::Boolean editRowDone(::CORBA::ULong pos, ::CORBA::Boolean newDone);
      Types::TStringSeq* variables();
      void variables(const Types::TStringSeq& _v);
      Types::TRowSeq* experiments();

      inline _objref_ExpSequence()  { _PR_setobj(0); }  // nil
      _objref_ExpSequence(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_ExpSequence();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_ExpSequence(const _objref_ExpSequence&);
      _objref_ExpSequence& operator = (const _objref_ExpSequence&);
      // not implemented

      friend class ExpSequence;
    };

    class _pof_ExpSequence : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_ExpSequence() : _OMNI_NS(proxyObjectFactory)(ExpSequence::_PD_repoId) {}
      virtual ~_pof_ExpSequence();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_ExpSequence :
      public virtual omniServant
    {
    public:
      virtual ~_impl_ExpSequence();

      virtual ::CORBA::Boolean setExpSequence(const Types::TStringSeq& Variables, const Types::TRowSeq& Experiments) = 0;
      virtual ::CORBA::Boolean appendRow(const Types::TStringSeq& newRow) = 0;
      virtual ::CORBA::Boolean moveRow(::CORBA::ULong oldPos, ::CORBA::ULong newPos) = 0;
      virtual ::CORBA::Boolean editRow(::CORBA::ULong pos, const Types::TRow& newRow) = 0;
      virtual ::CORBA::Boolean deleteRow(::CORBA::ULong pos) = 0;
      virtual void clear() = 0;
      virtual ::CORBA::Boolean editRowDone(::CORBA::ULong pos, ::CORBA::Boolean newDone) = 0;
      virtual Types::TStringSeq* variables() = 0;
      virtual void variables(const Types::TStringSeq& _v) = 0;
      virtual Types::TRowSeq* experiments() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mServerTimingSeqControl__
#define __STI_mClient__Server_mServerTimingSeqControl__

    class ServerTimingSeqControl;
    class _objref_ServerTimingSeqControl;
    class _impl_ServerTimingSeqControl;
    
    typedef _objref_ServerTimingSeqControl* ServerTimingSeqControl_ptr;
    typedef ServerTimingSeqControl_ptr ServerTimingSeqControlRef;

    class ServerTimingSeqControl_Helper {
    public:
      typedef ServerTimingSeqControl_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ServerTimingSeqControl, ServerTimingSeqControl_Helper> ServerTimingSeqControl_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ServerTimingSeqControl,ServerTimingSeqControl_Helper > ServerTimingSeqControl_out;

#endif

    // interface ServerTimingSeqControl
    class ServerTimingSeqControl {
    public:
      // Declarations for this interface type.
      typedef ServerTimingSeqControl_ptr _ptr_type;
      typedef ServerTimingSeqControl_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_ServerTimingSeqControl :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      Types::TStatus status();
      char* transferErr(const char* deviceID);
      void reset();
      void setDirect();
      void runSingle(::CORBA::Boolean documented);
      void runSequence(::CORBA::Boolean documented);
      void runSingleContinuous();
      void _cxx_continue();
      void pause();
      void resume();
      void stop();
      Types::TExpRunInfo* getDefaultRunInfo();
      Types::TExpSequenceInfo* getDefaultSequenceInfo();
      char* errMsg();

      inline _objref_ServerTimingSeqControl()  { _PR_setobj(0); }  // nil
      _objref_ServerTimingSeqControl(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_ServerTimingSeqControl();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_ServerTimingSeqControl(const _objref_ServerTimingSeqControl&);
      _objref_ServerTimingSeqControl& operator = (const _objref_ServerTimingSeqControl&);
      // not implemented

      friend class ServerTimingSeqControl;
    };

    class _pof_ServerTimingSeqControl : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_ServerTimingSeqControl() : _OMNI_NS(proxyObjectFactory)(ServerTimingSeqControl::_PD_repoId) {}
      virtual ~_pof_ServerTimingSeqControl();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_ServerTimingSeqControl :
      public virtual omniServant
    {
    public:
      virtual ~_impl_ServerTimingSeqControl();

      virtual Types::TStatus status() = 0;
      virtual char* transferErr(const char* deviceID) = 0;
      virtual void reset() = 0;
      virtual void setDirect() = 0;
      virtual void runSingle(::CORBA::Boolean documented) = 0;
      virtual void runSequence(::CORBA::Boolean documented) = 0;
      virtual void runSingleContinuous() = 0;
      virtual void _cxx_continue() = 0;
      virtual void pause() = 0;
      virtual void resume() = 0;
      virtual void stop() = 0;
      virtual Types::TExpRunInfo* getDefaultRunInfo() = 0;
      virtual Types::TExpSequenceInfo* getDefaultSequenceInfo() = 0;
      virtual char* errMsg() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mDocumentationSettings__
#define __STI_mClient__Server_mDocumentationSettings__

    class DocumentationSettings;
    class _objref_DocumentationSettings;
    class _impl_DocumentationSettings;
    
    typedef _objref_DocumentationSettings* DocumentationSettings_ptr;
    typedef DocumentationSettings_ptr DocumentationSettingsRef;

    class DocumentationSettings_Helper {
    public:
      typedef DocumentationSettings_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_DocumentationSettings, DocumentationSettings_Helper> DocumentationSettings_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_DocumentationSettings,DocumentationSettings_Helper > DocumentationSettings_out;

#endif

    // interface DocumentationSettings
    class DocumentationSettings {
    public:
      // Declarations for this interface type.
      typedef DocumentationSettings_ptr _ptr_type;
      typedef DocumentationSettings_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_DocumentationSettings :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      char* DocumentationBaseAbsDir();
      void DocumentationBaseAbsDir(const char* _v);
      char* DTDFileAbsDir();
      void DTDFileAbsDir(const char* _v);
      char* TimingFilesRelDir();
      void TimingFilesRelDir(const char* _v);
      char* DataFilesRelDir();
      void DataFilesRelDir(const char* _v);
      char* ExperimentFilesRelDir();
      void ExperimentFilesRelDir(const char* _v);
      char* SequenceFilesRelDir();
      void SequenceFilesRelDir(const char* _v);

      inline _objref_DocumentationSettings()  { _PR_setobj(0); }  // nil
      _objref_DocumentationSettings(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_DocumentationSettings();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_DocumentationSettings(const _objref_DocumentationSettings&);
      _objref_DocumentationSettings& operator = (const _objref_DocumentationSettings&);
      // not implemented

      friend class DocumentationSettings;
    };

    class _pof_DocumentationSettings : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_DocumentationSettings() : _OMNI_NS(proxyObjectFactory)(DocumentationSettings::_PD_repoId) {}
      virtual ~_pof_DocumentationSettings();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_DocumentationSettings :
      public virtual omniServant
    {
    public:
      virtual ~_impl_DocumentationSettings();

      virtual char* DocumentationBaseAbsDir() = 0;
      virtual void DocumentationBaseAbsDir(const char* _v) = 0;
      virtual char* DTDFileAbsDir() = 0;
      virtual void DTDFileAbsDir(const char* _v) = 0;
      virtual char* TimingFilesRelDir() = 0;
      virtual void TimingFilesRelDir(const char* _v) = 0;
      virtual char* DataFilesRelDir() = 0;
      virtual void DataFilesRelDir(const char* _v) = 0;
      virtual char* ExperimentFilesRelDir() = 0;
      virtual void ExperimentFilesRelDir(const char* _v) = 0;
      virtual char* SequenceFilesRelDir() = 0;
      virtual void SequenceFilesRelDir(const char* _v) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mRegisteredDevices__
#define __STI_mClient__Server_mRegisteredDevices__

    class RegisteredDevices;
    class _objref_RegisteredDevices;
    class _impl_RegisteredDevices;
    
    typedef _objref_RegisteredDevices* RegisteredDevices_ptr;
    typedef RegisteredDevices_ptr RegisteredDevicesRef;

    class RegisteredDevices_Helper {
    public:
      typedef RegisteredDevices_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_RegisteredDevices, RegisteredDevices_Helper> RegisteredDevices_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_RegisteredDevices,RegisteredDevices_Helper > RegisteredDevices_out;

#endif

    // interface RegisteredDevices
    class RegisteredDevices {
    public:
      // Declarations for this interface type.
      typedef RegisteredDevices_ptr _ptr_type;
      typedef RegisteredDevices_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_RegisteredDevices :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      Types::TAttributeSeq* getDeviceAttributes(const char* deviceID);
      ::CORBA::Boolean setDeviceAttribute(const char* deviceID, const char* key, const char* value);
      Types::TChannelSeq* getDeviceChannels(const char* deviceID);
      Types::TPartnerSeq* getDevicePartners(const char* deviceID);
      Types::TLabeledData* getLabledData(const char* deviceID, const char* label);
      ::CORBA::Boolean deviceStatus(const char* deviceID);
      ::CORBA::Long devicePing(const char* deviceID);
      void refreshDevices();
      void stopRefreshing();
      void killDevice(const char* deviceID);
      Types::TDeviceSeq* devices();

      inline _objref_RegisteredDevices()  { _PR_setobj(0); }  // nil
      _objref_RegisteredDevices(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_RegisteredDevices();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_RegisteredDevices(const _objref_RegisteredDevices&);
      _objref_RegisteredDevices& operator = (const _objref_RegisteredDevices&);
      // not implemented

      friend class RegisteredDevices;
    };

    class _pof_RegisteredDevices : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_RegisteredDevices() : _OMNI_NS(proxyObjectFactory)(RegisteredDevices::_PD_repoId) {}
      virtual ~_pof_RegisteredDevices();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_RegisteredDevices :
      public virtual omniServant
    {
    public:
      virtual ~_impl_RegisteredDevices();

      virtual Types::TAttributeSeq* getDeviceAttributes(const char* deviceID) = 0;
      virtual ::CORBA::Boolean setDeviceAttribute(const char* deviceID, const char* key, const char* value) = 0;
      virtual Types::TChannelSeq* getDeviceChannels(const char* deviceID) = 0;
      virtual Types::TPartnerSeq* getDevicePartners(const char* deviceID) = 0;
      virtual Types::TLabeledData* getLabledData(const char* deviceID, const char* label) = 0;
      virtual ::CORBA::Boolean deviceStatus(const char* deviceID) = 0;
      virtual ::CORBA::Long devicePing(const char* deviceID) = 0;
      virtual void refreshDevices() = 0;
      virtual void stopRefreshing() = 0;
      virtual void killDevice(const char* deviceID) = 0;
      virtual Types::TDeviceSeq* devices() = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mStreamingDataTransfer__
#define __STI_mClient__Server_mStreamingDataTransfer__

    class StreamingDataTransfer;
    class _objref_StreamingDataTransfer;
    class _impl_StreamingDataTransfer;
    
    typedef _objref_StreamingDataTransfer* StreamingDataTransfer_ptr;
    typedef StreamingDataTransfer_ptr StreamingDataTransferRef;

    class StreamingDataTransfer_Helper {
    public:
      typedef StreamingDataTransfer_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_StreamingDataTransfer, StreamingDataTransfer_Helper> StreamingDataTransfer_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_StreamingDataTransfer,StreamingDataTransfer_Helper > StreamingDataTransfer_out;

#endif

    // interface StreamingDataTransfer
    class StreamingDataTransfer {
    public:
      // Declarations for this interface type.
      typedef StreamingDataTransfer_ptr _ptr_type;
      typedef StreamingDataTransfer_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_StreamingDataTransfer :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      Types::TMeasurementSeq* getStreamingData(const char* deviceID, ::CORBA::UShort channel, ::CORBA::Double initial_t, ::CORBA::Double final_t, ::CORBA::Double delta_t);
      Types::TMeasurementSeq* getMeasurements(const char* deviceID);

      inline _objref_StreamingDataTransfer()  { _PR_setobj(0); }  // nil
      _objref_StreamingDataTransfer(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_StreamingDataTransfer();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_StreamingDataTransfer(const _objref_StreamingDataTransfer&);
      _objref_StreamingDataTransfer& operator = (const _objref_StreamingDataTransfer&);
      // not implemented

      friend class StreamingDataTransfer;
    };

    class _pof_StreamingDataTransfer : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_StreamingDataTransfer() : _OMNI_NS(proxyObjectFactory)(StreamingDataTransfer::_PD_repoId) {}
      virtual ~_pof_StreamingDataTransfer();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_StreamingDataTransfer :
      public virtual omniServant
    {
    public:
      virtual ~_impl_StreamingDataTransfer();

      virtual Types::TMeasurementSeq* getStreamingData(const char* deviceID, ::CORBA::UShort channel, ::CORBA::Double initial_t, ::CORBA::Double final_t, ::CORBA::Double delta_t) = 0;
      virtual Types::TMeasurementSeq* getMeasurements(const char* deviceID) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __STI_mClient__Server_mServerCommandLine__
#define __STI_mClient__Server_mServerCommandLine__

    class ServerCommandLine;
    class _objref_ServerCommandLine;
    class _impl_ServerCommandLine;
    
    typedef _objref_ServerCommandLine* ServerCommandLine_ptr;
    typedef ServerCommandLine_ptr ServerCommandLineRef;

    class ServerCommandLine_Helper {
    public:
      typedef ServerCommandLine_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_ServerCommandLine, ServerCommandLine_Helper> ServerCommandLine_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_ServerCommandLine,ServerCommandLine_Helper > ServerCommandLine_out;

#endif

    // interface ServerCommandLine
    class ServerCommandLine {
    public:
      // Declarations for this interface type.
      typedef ServerCommandLine_ptr _ptr_type;
      typedef ServerCommandLine_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_ServerCommandLine :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      char* deviceCmdName(const char* deviceID);
      char* executeArgs(const char* deviceID, const char* args);
      ::CORBA::Boolean writeChannel(const char* deviceID, ::CORBA::UShort channel, const Types::TValMixed& value);
      ::CORBA::Boolean readChannel(const char* deviceID, ::CORBA::UShort channel, const Types::TValMixed& value, Types::TDataMixed_out data);
      Types::TStringSeq* registeredPartners(const char* deviceID);
      Types::TStringSeq* requiredPartners(const char* deviceID);

      inline _objref_ServerCommandLine()  { _PR_setobj(0); }  // nil
      _objref_ServerCommandLine(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_ServerCommandLine();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_ServerCommandLine(const _objref_ServerCommandLine&);
      _objref_ServerCommandLine& operator = (const _objref_ServerCommandLine&);
      // not implemented

      friend class ServerCommandLine;
    };

    class _pof_ServerCommandLine : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_ServerCommandLine() : _OMNI_NS(proxyObjectFactory)(ServerCommandLine::_PD_repoId) {}
      virtual ~_pof_ServerCommandLine();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_ServerCommandLine :
      public virtual omniServant
    {
    public:
      virtual ~_impl_ServerCommandLine();

      virtual char* deviceCmdName(const char* deviceID) = 0;
      virtual char* executeArgs(const char* deviceID, const char* args) = 0;
      virtual ::CORBA::Boolean writeChannel(const char* deviceID, ::CORBA::UShort channel, const Types::TValMixed& value) = 0;
      virtual ::CORBA::Boolean readChannel(const char* deviceID, ::CORBA::UShort channel, const Types::TValMixed& value, Types::TDataMixed_out data) = 0;
      virtual Types::TStringSeq* registeredPartners(const char* deviceID) = 0;
      virtual Types::TStringSeq* requiredPartners(const char* deviceID) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_STI
_CORBA_MODULE_BEG

  _CORBA_MODULE Client_Server
  _CORBA_MODULE_BEG

    class ClientBootstrap :
      public virtual STI::Client_Server::_impl_ClientBootstrap,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~ClientBootstrap();

      inline ::STI::Client_Server::ClientBootstrap_ptr _this() {
        return (::STI::Client_Server::ClientBootstrap_ptr) _do_this(::STI::Client_Server::ClientBootstrap::_PD_repoId);
      }
    };

    class ModeInterrupt :
      public virtual STI::Client_Server::_impl_ModeInterrupt,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~ModeInterrupt();

      inline ::STI::Client_Server::ModeInterrupt_ptr _this() {
        return (::STI::Client_Server::ModeInterrupt_ptr) _do_this(::STI::Client_Server::ModeInterrupt::_PD_repoId);
      }
    };

    class ModeHandler :
      public virtual STI::Client_Server::_impl_ModeHandler,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~ModeHandler();

      inline ::STI::Client_Server::ModeHandler_ptr _this() {
        return (::STI::Client_Server::ModeHandler_ptr) _do_this(::STI::Client_Server::ModeHandler::_PD_repoId);
      }
    };

    class Parser :
      public virtual STI::Client_Server::_impl_Parser,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~Parser();

      inline ::STI::Client_Server::Parser_ptr _this() {
        return (::STI::Client_Server::Parser_ptr) _do_this(::STI::Client_Server::Parser::_PD_repoId);
      }
    };

    class ExpSequence :
      public virtual STI::Client_Server::_impl_ExpSequence,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~ExpSequence();

      inline ::STI::Client_Server::ExpSequence_ptr _this() {
        return (::STI::Client_Server::ExpSequence_ptr) _do_this(::STI::Client_Server::ExpSequence::_PD_repoId);
      }
    };

    class ServerTimingSeqControl :
      public virtual STI::Client_Server::_impl_ServerTimingSeqControl,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~ServerTimingSeqControl();

      inline ::STI::Client_Server::ServerTimingSeqControl_ptr _this() {
        return (::STI::Client_Server::ServerTimingSeqControl_ptr) _do_this(::STI::Client_Server::ServerTimingSeqControl::_PD_repoId);
      }
    };

    class DocumentationSettings :
      public virtual STI::Client_Server::_impl_DocumentationSettings,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~DocumentationSettings();

      inline ::STI::Client_Server::DocumentationSettings_ptr _this() {
        return (::STI::Client_Server::DocumentationSettings_ptr) _do_this(::STI::Client_Server::DocumentationSettings::_PD_repoId);
      }
    };

    class RegisteredDevices :
      public virtual STI::Client_Server::_impl_RegisteredDevices,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~RegisteredDevices();

      inline ::STI::Client_Server::RegisteredDevices_ptr _this() {
        return (::STI::Client_Server::RegisteredDevices_ptr) _do_this(::STI::Client_Server::RegisteredDevices::_PD_repoId);
      }
    };

    class StreamingDataTransfer :
      public virtual STI::Client_Server::_impl_StreamingDataTransfer,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~StreamingDataTransfer();

      inline ::STI::Client_Server::StreamingDataTransfer_ptr _this() {
        return (::STI::Client_Server::StreamingDataTransfer_ptr) _do_this(::STI::Client_Server::StreamingDataTransfer::_PD_repoId);
      }
    };

    class ServerCommandLine :
      public virtual STI::Client_Server::_impl_ServerCommandLine,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~ServerCommandLine();

      inline ::STI::Client_Server::ServerCommandLine_ptr _this() {
        return (::STI::Client_Server::ServerCommandLine_ptr) _do_this(::STI::Client_Server::ServerCommandLine::_PD_repoId);
      }
    };

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_STI
_CORBA_MODULE_BEG

  _CORBA_MODULE Client_Server
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr



inline void
STI::Client_Server::ClientBootstrap::_marshalObjRef(::STI::Client_Server::ClientBootstrap_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::ModeInterrupt::_marshalObjRef(::STI::Client_Server::ModeInterrupt_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::ModeHandler::_marshalObjRef(::STI::Client_Server::ModeHandler_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::Parser::_marshalObjRef(::STI::Client_Server::Parser_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::ExpSequence::_marshalObjRef(::STI::Client_Server::ExpSequence_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::ServerTimingSeqControl::_marshalObjRef(::STI::Client_Server::ServerTimingSeqControl_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::DocumentationSettings::_marshalObjRef(::STI::Client_Server::DocumentationSettings_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::RegisteredDevices::_marshalObjRef(::STI::Client_Server::RegisteredDevices_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::StreamingDataTransfer::_marshalObjRef(::STI::Client_Server::StreamingDataTransfer_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}


inline void
STI::Client_Server::ServerCommandLine::_marshalObjRef(::STI::Client_Server::ServerCommandLine_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_client
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_client
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_client
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_client
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_client
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_client
#endif

#endif  // __client_hh__

